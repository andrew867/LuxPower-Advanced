# ESPHome Configuration for Waveshare ESP32-S3-Relay-6CH
# Modbus RTU → MQTT bridge for LuxPower or other Modbus devices

esphome:
  name: modbus-bridge
  friendly_name: Modbus RTU Bridge

esp32:
  variant: esp32s3
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:
  level: INFO
  # baud_rate: 0  # uncomment if UART0 logging conflicts with RS485

api:
  encryption:
    key: !secret api_key

ota:
  platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  reboot_timeout: 15min
  power_save_mode: none

captive_portal:

mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  port: 1883
  discovery: true
  discovery_prefix: homeassistant
  topic_prefix: modbus_bridge
  keepalive: 15s
  birth_message:
    topic: modbus_bridge/status
    payload: online
  will_message:
    topic: modbus_bridge/status
    payload: offline

# RS485 UART (DI=TXD'→GPIO17, RO=RXD'←GPIO18). RE/DE is auto-driven from TX via 74HC04, so omit flow_control_pin.
uart:
  id: rs485_uart
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 19200
  data_bits: 8
  stop_bits: 1
  parity: NONE
  rx_buffer_size: 512

modbus:
  id: mbus
  uart_id: rs485_uart
  send_wait_time: 250ms

modbus_controller:
  - id: lux
    modbus_id: mbus
    address: 0x01
    update_interval: 1s
    command_throttle: 0ms
    offline_skip_updates: 0

# Relays per Waveshare mapping
switch:
  - platform: gpio
    name: "Relay 1"
    pin: GPIO1
    id: relay1
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 2"
    pin: GPIO2
    id: relay2
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 3"
    pin: GPIO41
    id: relay3
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 4"
    pin: GPIO42
    id: relay4
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 5"
    pin: GPIO45
    id: relay5
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 6"
    pin: GPIO46
    id: relay6
    restore_mode: RESTORE_DEFAULT_OFF

# Buzzer on GPIO21
output:
  - platform: gpio
    pin: GPIO21
    id: buzzer_output
    inverted: false

button:
  - platform: template
    name: "Buzzer Test"
    id: buzzer_test
    on_press:
      - output.turn_on: buzzer_output
      - delay: 200ms
      - output.turn_off: buzzer_output

# Boot button on GPIO0
binary_sensor:
  - platform: gpio
    name: "Boot Button"
    pin:
      number: GPIO0
      mode:
        input: true
        pullup: true
      inverted: true

# RGB LED on GPIO38
light:
  - platform: esp32_rmt_led_strip
    name: "Bridge LED"
    id: bridge_led
    pin: GPIO38
    num_leds: 1
    chipset: ws2812
    rgb_order: GRB
    effects:
      - pulse:
          name: "Pulse"
          transition_length: 1s
          update_interval: 1s
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10
          width: 1

sensor:
  - platform: uptime
    name: "Uptime"

# Text sensors, device ID and Modbus banks → MQTT JSON
text_sensor:
  - platform: template
    name: "Device ID"
    id: device_id
    lambda: |-
      std::string mac = get_mac_address();  // "AA:BB:CC:DD:EE:FF"
      std::string compact;
      compact.reserve(mac.size());
      for (char c : mac) if (c != ':') compact.push_back(c);
      return std::string("modbus_bridge_") + compact;

  # Input-register banks (FC04), parsed and published as JSON
  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank0_raw
    internal: true
    register_type: read
    address: 0
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - mqtt.publish:
            topic: modbus_bridge/data/bank0
            payload: !lambda |-
              const std::string &hex = id(bank0_raw).state;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":0,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t v = (uint16_t) strtoul(hex.substr(i, 4).c_str(), nullptr, 16);
                json += to_string(v);
              }
              json += "]}";
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank1_raw
    internal: true
    register_type: read
    address: 40
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - mqtt.publish:
            topic: modbus_bridge/data/bank1
            payload: !lambda |-
              const std::string &hex = id(bank1_raw).state;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":40,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t v = (uint16_t) strtoul(hex.substr(i, 4).c_str(), nullptr, 16);
                json += to_string(v);
              }
              json += "]}";
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank2_raw
    internal: true
    register_type: read
    address: 80
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - mqtt.publish:
            topic: modbus_bridge/data/bank2
            payload: !lambda |-
              const std::string &hex = id(bank2_raw).state;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":80,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t v = (uint16_t) strtoul(hex.substr(i, 4).c_str(), nullptr, 16);
                json += to_string(v);
              }
              json += "]}";
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank3_raw
    internal: true
    register_type: read
    address: 120
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - mqtt.publish:
            topic: modbus_bridge/data/bank3
            payload: !lambda |-
              const std::string &hex = id(bank3_raw).state;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":120,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t v = (uint16_t) strtoul(hex.substr(i, 4).c_str(), nullptr, 16);
                json += to_string(v);
              }
              json += "]}";
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank4_raw
    internal: true
    register_type: read
    address: 160
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - mqtt.publish:
            topic: modbus_bridge/data/bank4
            payload: !lambda |-
              const std::string &hex = id(bank4_raw).state;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":160,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t v = (uint16_t) strtoul(hex.substr(i, 4).c_str(), nullptr, 16);
                json += to_string(v);
              }
              json += "]}";
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank5_raw
    internal: true
    register_type: read
    address: 200
    register_count: 54
    response_size: 108
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - mqtt.publish:
            topic: modbus_bridge/data/bank5
            payload: !lambda |-
              const std::string &hex = id(bank5_raw).state;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":200,\"register_count\":54,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 54; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t v = (uint16_t) strtoul(hex.substr(i, 4).c_str(), nullptr, 16);
                json += to_string(v);
              }
              json += "]}";
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank6_raw
    internal: true
    register_type: read
    address: 254
    register_count: 127
    response_size: 254
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - mqtt.publish:
            topic: modbus_bridge/data/bank6
            payload: !lambda |-
              const std::string &hex = id(bank6_raw).state;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":254,\"register_count\":127,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 127; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t v = (uint16_t) strtoul(hex.substr(i, 4).c_str(), nullptr, 16);
                json += to_string(v);
              }
              json += "]}";
              return json;
