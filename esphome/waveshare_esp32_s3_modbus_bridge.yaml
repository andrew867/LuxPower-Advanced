# ESPHome Configuration for Waveshare ESP32-S3-Relay-6CH
# Modbus RTU ‚Üí MQTT bridge for LuxPower or other Modbus devices

esphome:
  name: modbus-bridge
  friendly_name: Modbus RTU Bridge

esp32:
  variant: esp32s3
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:
  level: INFO
  # baud_rate: 0  # uncomment if UART0 logging conflicts with RS485

api:
  encryption:
    key: !secret api_key

ota:
  platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  reboot_timeout: 0s
  power_save_mode: none

captive_portal:

mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  port: 1883
  discovery: true
  discovery_prefix: homeassistant
  topic_prefix: modbus_bridge
  keepalive: 15s
  birth_message:
    topic: modbus_bridge/status
    payload: '{"status":"online"}'
    qos: 1
    retain: true
  will_message:
    topic: modbus_bridge/status
    payload: '{"status":"offline"}'
    qos: 1
    retain: true
  on_connect:
    then:
      - lambda: |-
          ESP_LOGI("mqtt", "üîó MQTT connected - Modbus bridge ready");
          id(mqtt_offline_since) = 0;
  on_disconnect:
    then:
      - lambda: |-
          ESP_LOGW("mqtt", "üîå MQTT disconnected - Modbus bridge offline");
          if (id(mqtt_offline_since) == 0) { id(mqtt_offline_since) = esphome::millis(); }
  on_json_message:
    - topic: modbus_bridge/write
      then:
        - lambda: |-
            // Expected payload: {"function":"write_single","register":<int>,"value":<int>,"seq":<int>}
            if (!x.containsKey("register") || !x.containsKey("value")) {
              ESP_LOGW("mqtt", "Write command missing fields");
              return;
            }
            int reg = x["register"].as<int>();
            int val = x["value"].as<int>();
            int seq_in = x.containsKey("seq") ? x["seq"].as<int>() : 0;
            id(write_target_reg) = reg;
            id(write_target_val) = val;
            id(write_seq_in) = seq_in;
        - modbus_controller.write:
            id: lux
            register_type: holding
            address: !lambda 'return id(write_target_reg);'
            value: !lambda 'return id(write_target_val);'
        - mqtt.publish:
            topic: modbus_bridge/write/ack
            payload: !lambda |-
              char buf[96];
              snprintf(buf, sizeof(buf), "{\"seq\":%d,\"status\":\"ok\",\"register\":%d,\"value\":%d}", id(write_seq_in), id(write_target_reg), id(write_target_val));
              return std::string(buf);
            qos: 1
    - topic: !lambda |-
        // Per-device write topic variant
        std::string t = "modbus_bridge/";
        t += id(device_id).state;
        t += "/write";
        return t;
      then:
        - lambda: |-
            if (!x.containsKey("register") || !x.containsKey("value")) {
              ESP_LOGW("mqtt", "Write command missing fields (per-device)");
              return;
            }
            int reg = x["register"].as<int>();
            int val = x["value"].as<int>();
            int seq_in = x.containsKey("seq") ? x["seq"].as<int>() : 0;
            id(write_target_reg) = reg;
            id(write_target_val) = val;
            id(write_seq_in) = seq_in;
        - modbus_controller.write:
            id: lux
            register_type: holding
            address: !lambda 'return id(write_target_reg);'
            value: !lambda 'return id(write_target_val);'
        - mqtt.publish:
            topic: !lambda |-
              std::string t = "modbus_bridge/";
              t += id(device_id).state;
              t += "/write/ack";
              return t;
            payload: !lambda |-
              char buf[96];
              snprintf(buf, sizeof(buf), "{\"seq\":%d,\"status\":\"ok\",\"register\":%d,\"value\":%d}", id(write_seq_in), id(write_target_reg), id(write_target_val));
              return std::string(buf);
            qos: 1

# RS485 UART (DI=TXD'‚ÜíGPIO17, RO=RXD'‚ÜêGPIO18). RE/DE is auto-driven from TX via 74HC04, so omit flow_control_pin.
# LuxPower specs: 19200bps, 8N1 (8 data bits, no parity, 1 stop bit)
# IMPORTANT: If you have bus conflicts with WiFi dongle, try swapping A+ and B- connections
uart:
  id: rs485_uart
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 19200
  data_bits: 8
  stop_bits: 1
  parity: NONE
  rx_buffer_size: 512

modbus:
  id: mbus
  uart_id: rs485_uart
  send_wait_time: 1000ms  # Tuned to reduce contention while avoiding conflicts

modbus_controller:
  - id: lux
    modbus_id: mbus
    address: 0x01
    update_interval: 60000ms  # Increased to 60s to avoid conflicts with WiFi dongle
    command_throttle: 1000ms  # Increased throttle to be more conservative
    offline_skip_updates: 0

# Scripts for Modbus statistics and error tracking
script:
  - id: log_modbus_stats
    then:
      - lambda: |-
          ESP_LOGI("modbus", "üìä Modbus Statistics: Polling every 30s, 10 banks total (40 registers each), LuxPower byte order (per spec)");
          ESP_LOGI("modbus", "‚ö†Ô∏è  BUS ARBITRATION: 30s interval to avoid conflicts with WiFi dongle (15s polling)");
  
  - id: publish_status_update
    then:
      - mqtt.publish:
          topic: modbus_bridge/status
          payload: !lambda |-
            id(seq)++;
            return "{\"status\":\"online\",\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000)) + ",\"seq\":" + to_string(id(seq)) + "}";
          qos: 1
          retain: true

  # Bus arbitration script - check for bus activity before polling
  - id: check_bus_activity
    then:
      - lambda: |-
          ESP_LOGI("modbus", "üîç Checking bus activity before polling...");
          // Add a small random delay to avoid synchronized polling
          uint32_t random_delay = (esphome::millis() % 5000) + 1000; // 1-6 second random delay
          ESP_LOGI("modbus", "‚è±Ô∏è  Random delay: %u ms", random_delay);
          delay(random_delay);

# Relays per Waveshare mapping
switch:
  - platform: gpio
    name: "Relay 1"
    pin: GPIO1
    id: relay1
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 2"
    pin: GPIO2
    id: relay2
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 3"
    pin: GPIO41
    id: relay3
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 4"
    pin: GPIO42
    id: relay4
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 5"
    pin: GPIO45
    id: relay5
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "Relay 6"
    pin: GPIO46
    id: relay6
    restore_mode: RESTORE_DEFAULT_OFF

# Buzzer on GPIO21
output:
  - platform: gpio
    pin: GPIO21
    id: buzzer_output
    inverted: false

button:
  - platform: template
    name: "Buzzer Test"
    id: buzzer_test
    on_press:
      - output.turn_on: buzzer_output
      - delay: 200ms
      - output.turn_off: buzzer_output

# Boot button on GPIO0
binary_sensor:
  - platform: gpio
    name: "Boot Button"
    pin:
      number: GPIO0
      mode:
        input: true
        pullup: true
      inverted: true

# RGB LED on GPIO38
light:
  - platform: esp32_rmt_led_strip
    name: "Bridge LED"
    id: bridge_led
    pin: GPIO38
    num_leds: 1
    chipset: ws2812
    rgb_order: GRB
    effects:
      - pulse:
          name: "Pulse"
          transition_length: 1s
          update_interval: 1s
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10
          width: 1

sensor:
  - platform: uptime
    name: "Uptime"

# Interval for periodic logging and status updates
interval:
  - interval: 30s
    then:
      - script.execute: log_modbus_stats
      - script.execute: publish_status_update

globals:
  - id: seq
    type: uint32_t
    restore_value: yes
    initial_value: '0'
  - id: mqtt_offline_since
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: write_target_reg
    type: int
    restore_value: no
    initial_value: '0'
  - id: write_target_val
    type: int
    restore_value: no
    initial_value: '0'
  - id: write_seq_in
    type: int
    restore_value: no
    initial_value: '0'

# Text sensors, device ID and Modbus banks ‚Üí MQTT JSON
text_sensor:
  - platform: template
    name: "Device ID"
    id: device_id
    lambda: |-
      std::string mac = get_mac_address();  // "AA:BB:CC:DD:EE:FF"
      std::string compact;
      compact.reserve(mac.size());
      for (char c : mac) if (c != ':') compact.push_back(c);
      return std::string("modbus_bridge_") + compact;

  # Input-register banks (FC04), parsed and published as JSON
  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank0_raw
    internal: true
    register_type: input
    address: 0
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank0_raw).state;
            if (hex.empty()) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank0: Empty response received - possible bus conflict");
              return;
            }
            if (hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank0: Incomplete response (%d bytes, expected 80) - possible bus conflict", hex.size());
              return;
            }
            auto parse16 = [&](size_t i) -> uint16_t {
              if (i + 3 >= hex.size()) return 0;
              // LuxPower spec: 16-bit integers have high/low byte order reversed
              // 0x01 0x02 should be parsed as 0x0201 = 513 (per official docs)
              uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
              uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
              return (low_byte << 8) | high_byte;
            };
            uint16_t v0 = parse16(0);
            uint16_t v1 = parse16(4);
            uint16_t v2 = parse16(8);
            uint16_t v3 = parse16(12);
            uint16_t v4 = parse16(16);
            uint16_t v5 = parse16(20);
            ESP_LOGI("modbus", "‚úÖ Bank0: Good data [0..5]: %u, %u, %u, %u, %u, %u", v0, v1, v2, v3, v4, v5);
        - mqtt.publish:
            topic: modbus_bridge/data/bank0
            payload: !lambda |-
              const std::string &hex = id(bank0_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":0,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank1_raw
    internal: true
    register_type: input
    address: 40
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank1_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank1: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Bank1: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/data/bank1
            payload: !lambda |-
              const std::string &hex = id(bank1_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":40,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank2_raw
    internal: true
    register_type: input
    address: 80
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank2_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank2: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Bank2: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/data/bank2
            payload: !lambda |-
              const std::string &hex = id(bank2_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":80,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank3_raw
    internal: true
    register_type: input
    address: 120
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank3_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank3: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Bank3: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/data/bank3
            payload: !lambda |-
              const std::string &hex = id(bank3_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":120,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank4_raw
    internal: true
    register_type: input
    address: 160
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank4_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank4: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Bank4: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/data/bank4
            payload: !lambda |-
              const std::string &hex = id(bank4_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":160,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  # Bank 5: Registers 200-239 (40 registers)
  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank5_raw
    internal: true
    register_type: input
    address: 200
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank5_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank5: Bad data (%d bytes, expected 80)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Bank5: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/data/bank5
            payload: !lambda |-
              const std::string &hex = id(bank5_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":200,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  # Bank 6: Registers 240-279 (40 registers)
  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank6_raw
    internal: true
    register_type: input
    address: 240
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank6_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank6: Bad data (%d bytes, expected 80)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Bank6: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/data/bank6
            payload: !lambda |-
              const std::string &hex = id(bank6_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":240,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  # Bank 7: Registers 280-319 (40 registers)
  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank7_raw
    internal: true
    register_type: input
    address: 280
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank7_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank7: Bad data (%d bytes, expected 80)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Bank7: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/data/bank7
            payload: !lambda |-
              const std::string &hex = id(bank7_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":280,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  # Bank 8: Registers 320-359 (40 registers)
  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank8_raw
    internal: true
    register_type: input
    address: 320
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank8_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank8: Bad data (%d bytes, expected 80)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Bank8: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/data/bank8
            payload: !lambda |-
              const std::string &hex = id(bank8_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":320,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  # Bank 9: Registers 360-399 (40 registers)
  - platform: modbus_controller
    modbus_controller_id: lux
    id: bank9_raw
    internal: true
    register_type: input
    address: 360
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(bank9_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Bank9: Bad data (%d bytes, expected 80)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Bank9: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/data/bank9
            payload: !lambda |-
              const std::string &hex = id(bank9_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":360,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                // LuxPower spec: 16-bit integers have high/low byte order reversed
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  # Holding-register banks (FC03), published as JSON
  - platform: modbus_controller
    modbus_controller_id: lux
    id: hold_bank0_raw
    internal: true
    register_type: holding
    address: 0
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(hold_bank0_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Hold Bank0: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Hold Bank0: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/hold/bank0
            payload: !lambda |-
              const std::string &hex = id(hold_bank0_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":0,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: hold_bank1_raw
    internal: true
    register_type: holding
    address: 40
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(hold_bank1_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Hold Bank1: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Hold Bank1: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/hold/bank1
            payload: !lambda |-
              const std::string &hex = id(hold_bank1_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":40,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: hold_bank2_raw
    internal: true
    register_type: holding
    address: 80
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(hold_bank2_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Hold Bank2: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Hold Bank2: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/hold/bank2
            payload: !lambda |-
              const std::string &hex = id(hold_bank2_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":80,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: hold_bank3_raw
    internal: true
    register_type: holding
    address: 120
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(hold_bank3_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Hold Bank3: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Hold Bank3: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/hold/bank3
            payload: !lambda |-
              const std::string &hex = id(hold_bank3_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":120,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: hold_bank4_raw
    internal: true
    register_type: holding
    address: 160
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(hold_bank4_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Hold Bank4: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Hold Bank4: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/hold/bank4
            payload: !lambda |-
              const std::string &hex = id(hold_bank4_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":160,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: hold_bank5_raw
    internal: true
    register_type: holding
    address: 200
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(hold_bank5_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Hold Bank5: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Hold Bank5: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/hold/bank5
            payload: !lambda |-
              const std::string &hex = id(hold_bank5_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":200,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: hold_bank6_raw
    internal: true
    register_type: holding
    address: 240
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(hold_bank6_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Hold Bank6: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Hold Bank6: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/hold/bank6
            payload: !lambda |-
              const std::string &hex = id(hold_bank6_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":240,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;

  - platform: modbus_controller
    modbus_controller_id: lux
    id: hold_bank7_raw
    internal: true
    register_type: holding
    address: 280
    register_count: 40
    response_size: 80
    raw_encode: HEXBYTES
    force_new_range: true
    on_value:
      then:
        - lambda: |-
            const std::string &hex = id(hold_bank7_raw).state;
            if (hex.empty() || hex.size() < 80) {
              ESP_LOGW("modbus", "‚ö†Ô∏è  Hold Bank7: Bad data (%d bytes)", hex.size());
            } else {
              ESP_LOGI("modbus", "‚úÖ Hold Bank7: Good data received");
            }
        - mqtt.publish:
            topic: modbus_bridge/hold/bank7
            payload: !lambda |-
              const std::string &hex = id(hold_bank7_raw).state;
              id(seq)++;
              std::string json = "{\"timestamp\":" + to_string((uint32_t)(esphome::millis()/1000))
                                 + ",\"register_start\":280,\"register_count\":40,\"values\":[";
              for (size_t i = 0, idx = 0; i + 3 < hex.size() && idx < 40; i += 4, idx++) {
                if (idx) json += ",";
                uint16_t high_byte = (uint16_t) strtoul(hex.substr(i, 2).c_str(), nullptr, 16);
                uint16_t low_byte = (uint16_t) strtoul(hex.substr(i + 2, 2).c_str(), nullptr, 16);
                uint16_t v = (low_byte << 8) | high_byte;
                json += to_string(v);
              }
              json += "],\"seq\":" + to_string(id(seq)) + "}";
            qos: 1
            retain: true
              return json;